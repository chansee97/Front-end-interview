## $nextTick使用场景和原理

1. 应用：vue中的nextTick主要用于处理数据动态变化后，DOM还未及时更新的问题，用nextTick就可以获取数据更新后最新DOM的变化。

2. 场景：

- 第三方插件，在vue生成的某些dom动态发生变化时重新应用该插件

- 视图更新之后，基于新的视图进行操作

3. 使用原理:

- Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作，这样可以提高渲染效率。

- 如果要获取更新后的DOM元素，可以使用vue内置的$nextTick方法，参数是一个函数。它的作用类似setTimeout，进行执行异步的操作。

## $nextTick 和 setTimeout 有什么区别？

`$nextTick`在vue 源码中是利用 `Promise.resolve()`实现的。该问题实际就是`Promise`与`setTimeout`的区别，本质是`Event Loop`中微任务与宏任务的区别。

**$nextTick**：一般使用在DOM操作上的，Vue在更新data之后并不会立即更新DOM上的数据，就是说如果我们修改了data中的数据，再马上获取DOM上的值，我们取得的是旧值。官网的原话是`在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。`我们把获取DOM上值的操作放进$nextTick里，就可以得到更新后得数据。

**setTimeout**：就是个延时回调，和DOM操作无关。

## 组件通信方式

1. props / $emit
2. $children / $parent
3.  provide/ reject
4. ref
5. eventBus
6. Vuex
7. localStorage / sessionStorage
8. $attrs与$listeners

## computer和watch区别

**wactch：**

1. 不支持缓存。数据变化直接触发操作；
2.watch支持异步；
3.监听的函数接收两个参数（newValue, oldValue）
2. 当一个属性发生变化时，需要执行对应的操作；一对多；
3. 监听数据必须是data中声明过或者父组件传递过来的props中的数据。
页面第一次渲染时候，watch函数是不会执行的，只有当数据变化时才会触发操作。函数有两个参数，
deep 控制是否要看这个对象里面的属性变化，但是其无法监听到数组的变动和对象的新增
immediate 控制是否在第一次渲染是执行这个函数
举例场景：现在有父组件P，和他的2个子组件C1，C2。C1改变父组件P的data，并且需要把这个值传给C2，这时候发现C2组件的data值没有变换还是最初父组件P传的值，考虑在组件C2中用watch来解决

**computer：**

1. 支持缓存，只有依赖数据发生改变，才会重新进行计算
2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化
3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值
3. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed
5. 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

## 什么时候使用vuex

能够直接通信的就直接通信好了，没问题的。如果一个数据涉及的组件对象之间的兄弟关系，或者一个数据在多于两个组件中使用，或者数据是业务核心数据，不确定你的业务场景。那就放到 store 里。

我这里举个例子：

在线机票预订系统，乘机人信息会在增值业务购买、价格展示、在线支付等组件中使用，同时这个数据也是业务核心数据，因此就将乘机人数组放到 store 中，而乘机人组件是由一个包装父组件加 单个乘机人信息 的子组件列表构成，包装父组件和子组件之间就直接通过 props 传递单个乘机人数据，没必要再通过 store 传递

## vuex和mixin的区别

**mixins**

:局部调用，不影响全局；在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。

**vuex**

本地仓库，影响全局数据

## 单向数据流

vue中子组件可以使用父组件传递过来的数据，但是绝对不能修改传递过来的数据，保持单向数据流确保数据的可溯源性。

## 如何监测多个动态路由变化

方式一：监听 $route

方式二：通过组件内的导航守卫，beforeRouteUpdate , （和created(){}生命周期函数同级别）；

## 单页面开发与多页面开发的优缺点。

1.单页面开发的优缺点；

优点：网站所有功能呈现于一整张页面中，用户体验较好，用户不用在寻找某一功能时在网页之间穿梭，节省了用户时间，提高了用户的查找效率，对服务器请求较少，减轻了服务器的压力，只需要一次加载，页面片段之间切换快，用户体验良好，并且由于是单页面，所以维护成本较低。

缺点：网站功能复杂；网站优化相对困难；也导致在网站第一次加载时耗费时间较长；构建困难，需要单独的方案。

2.多页面开发的优缺点；

优点：多个页面之间跳转，用户可以清晰的了解整个网站的内容构成；页面结构的分布也不会很拥挤；实现简单，开发成本低；适用于对搜索引擎支持较高，页面跳转较少，数据传递较少的项目中开发。

缺点：页面跳转时，要重新执行css，js等文件，页面片段之间跳转较慢，需要用到页面跨页面传值的几种方法；实现转场动画比较困难。维护成本高。

## Object.defineProperty的缺陷

**无法检测到对象属性的新增或删除**

**无法监听数组变化**

- vue实现响应式时，把无法监听数组 的情况通过重写数组的部分方法来实现响应式，但是只局限在以下7种方法`push`、`pop`、`shift`、`unshift`、`splice`、`sort`、`reverse`